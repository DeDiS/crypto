package vss

import (
	"bytes"
	"crypto/cipher"
	"encoding/binary"
	"errors"
	"fmt"

	"github.com/dedis/crypto/abstract"
	"github.com/dedis/crypto/share"
	"github.com/dedis/crypto/share/vss"
	"github.com/dedis/crypto/sign"
)

type DistKeyShare struct {
	Public abstract.Point

	// share of the distributed secret
	Share *share.PriShare
}

// DistDeal is a simple wrapper around Deal used to provide the index of the
// Dealer in the list of participants together with its Deal.
// NOTE: Doing that in vss.go would be possible but then the Dealer is always
// assumed to be a member of the participants. It's only the case here.
type Deal struct {
	// Index of the Dealer in the list of participants
	Index uint32
	Deal  *vss.Deal
}

type Response struct {
	// Index of the Dealer for which this response is for
	Index uint32

	Response *vss.Response
}

type Justification struct {
	// Index of the Dealer who answered with this Justification
	Index uint32

	Justification *vss.Justification
}

// SecretCommit is sent during the distributed public key reconstruction phase,
// basically a Feldman VSS scheme.
type SecretCommits struct {
	// SessionID generated by the Dealer
	SessionID []byte
	// Index of the Dealer in the list of participants
	Index uint32
	// Commitments generated by the Dealer
	Commitments []abstract.Point
	// Signature from the Dealer
	Signature []byte
}

type ComplaintCommits struct {
	// Index of the Verifier _issuing_ the ComplaintCommit
	Index uint32
	// DealerIndex being the index of the Dealer who issued the SecretCommits
	DealerIndex uint32
	// Deal that has been given from the Dealer (at DealerIndex) to this node
	// (at Index)
	Deal *vss.Deal
	// SessionID generated by the Dealer who issued the SecretCommits
	SessionID []byte
	// Signature made by the verifier
	Signature []byte
}

type DistKeyGenerator struct {
	suite abstract.Suite

	index uint32
	long  abstract.Scalar
	pub   abstract.Point

	participants []abstract.Point

	t int

	dealer    *vss.Dealer
	verifiers map[uint32]*vss.Verifier

	commitments   map[uint32]*share.PubPoly
	reconstructed map[uint32]bool
}

func NewDistKeyGenerator(suite abstract.Suite, longterm abstract.Scalar, participants []abstract.Point, r cipher.Stream, t int) (*DistKeyGenerator, error) {
	d := new(DistKeyGenerator)
	pub := suite.Point().Mul(nil, longterm)
	// find our index
	var found bool
	for i, p := range participants {
		if p.Equal(pub) {
			found = true
			d.index = uint32(i)
			break
		}
	}
	if !found {
		return nil, errors.New("dkg: own public key not found in list of participants")
	}
	var err error
	// generate our dealer / deal
	ownSec := suite.Scalar().Pick(r)
	d.dealer, err = vss.NewDealer(suite, longterm, ownSec, participants, r, t)
	if err != nil {
		return nil, err
	}
	// to receive the other deals
	d.verifiers = make(map[uint32]*vss.Verifier)
	d.commitments = make(map[uint32]*share.PubPoly)
	d.reconstructed = make(map[uint32]bool)
	d.t = t
	d.suite = suite
	d.long = longterm
	d.pub = pub
	d.participants = participants
	return d, nil
}

// DistDeals returns all the DistDeal that must be broadcasted to every
// participants. The DistDeal corresponding to this DKG is already added
// to this DKG and is ommitted from the returned map. To know
// to which participant to give the DistDeal, loop over the keys as indexes in
// the list of participants:
//   for i,dd := range distDeals {
//      sendTo(participants[i],dd)
//   }
//
func (d *DistKeyGenerator) Deals() map[int]*Deal {
	deals := d.dealer.Deals()
	dd := make(map[int]*Deal)
	for i := range d.participants {
		distd := &Deal{
			Index: d.index,
			Deal:  deals[i],
		}
		if i == int(d.index) {
			if resp, err := d.ProcessDeal(distd); err != nil {
				panic(err)
			} else if resp.Response.Status != vss.StatusApproval {
				panic("dkg: own deal gave a complaint")
			}
			continue
		}
		dd[i] = distd
	}
	return dd
}

func (d *DistKeyGenerator) ProcessDeal(dd *Deal) (*Response, error) {
	// public key of the dealer
	pub, ok := findPub(d.participants, dd.Index)
	if !ok {
		return nil, errors.New("dkg: dist deal out of bounds index")
	}

	if _, ok := d.verifiers[dd.Index]; ok {
		return nil, errors.New("dkg: already received dist deal from same index")
	}

	// verifier receiving the dealer's deal
	ver, err := vss.NewVerifier(d.suite, d.long, pub, d.participants)
	if err != nil {
		return nil, err
	}

	d.verifiers[dd.Index] = ver
	resp, err := ver.ProcessDeal(dd.Deal)
	return &Response{
		Index:    dd.Index,
		Response: resp,
	}, err
}

func (d *DistKeyGenerator) ProcessResponse(resp *Response) (*Justification, error) {
	v, ok := d.verifiers[resp.Index]
	if !ok {
		return nil, errors.New("dkg: complaint received but no deal for it")
	}

	if err := v.ProcessResponse(resp.Response); err != nil {
		fmt.Println("Here")
		return nil, err
	}

	if resp.Index == uint32(d.index) {
		j, err := d.dealer.ProcessResponse(resp.Response)
		if err != nil {
			panic(err)
		}
		if j != nil {
			// should not really happen that our own deal needs justification...
			if err := v.ProcessJustification(j); err != nil {
				panic(err)
			}
			return &Justification{
				Index:         d.index,
				Justification: j,
			}, err
		}
	}
	return nil, nil
}

func (d *DistKeyGenerator) ProcessJustification(j *Justification) error {
	if v, ok := d.verifiers[j.Index]; !ok {
		return errors.New("dkg: Justification received but no deal for it")
	} else {
		return v.ProcessJustification(j.Justification)
	}
}

func (d *DistKeyGenerator) Certified() bool {
	var goodDeal int
	var commitments = true
	d.qualIter(func(i uint32, v *vss.Verifier) bool {
		goodDeal++
		_, ok := d.commitments[i]
		if !ok {
			commitments = false
			return false
		}
		return true
	})
	return goodDeal >= d.t && commitments
}

func (d *DistKeyGenerator) QUAL() []abstract.Point {
	var good []abstract.Point
	d.qualIter(func(i uint32, v *vss.Verifier) bool {
		_, pub := v.Key()
		good = append(good, pub)
		return true
	})
	return good
}

func (d *DistKeyGenerator) isInQUAL(idx uint32) bool {
	var found bool
	d.qualIter(func(i uint32, v *vss.Verifier) bool {
		if i == idx {
			found = true
			return false
		}
		return true
	})
	return found
}

func (d *DistKeyGenerator) qualIter(fn func(idx uint32, v *vss.Verifier) bool) {
	for i, v := range d.verifiers {
		if v.EnoughApprovals() && v.DealCertified() {
			if !fn(i, v) {
				break
			}
		}
	}
}

// Feldman VSS
func (d *DistKeyGenerator) SecretCommits() (*SecretCommits, error) {
	if !d.dealer.DealCertified() {
		return nil, errors.New("dkg: can't give SecretCommits if deal not certified")
	}
	sc := &SecretCommits{
		Commitments: d.dealer.Commits(),
		Index:       uint32(d.index),
		SessionID:   d.dealer.SessionID(),
	}
	msg := msgSecretCommit(sc)
	sig, err := sign.Schnorr(d.suite, d.long, msg)
	if err != nil {
		return nil, err
	}
	sc.Signature = sig
	// adding our own commitments
	d.commitments[uint32(d.index)] = share.NewPubPoly(d.suite, d.suite.Point().Base(), sc.Commitments)
	return sc, err
}

// Feldman VSS
func (d *DistKeyGenerator) ProcessSecretCommits(sc *SecretCommits) (*ComplaintCommits, error) {
	pub, ok := findPub(d.participants, sc.Index)
	if !ok {
		return nil, errors.New("dkg: secretcommits received with index out of bounds")
	}

	if !d.isInQUAL(sc.Index) {
		return nil, errors.New("dkg: secretcommits from a non QUAL member")
	}

	v, ok := d.verifiers[sc.Index]
	if !ok {
		return nil, errors.New("dkg: secretcommits received without corresponding verifier")
	}

	if !bytes.Equal(v.SessionID(), sc.SessionID) {
		return nil, errors.New("dkg: secretcommits received with wrong session id")
	}

	msg := msgSecretCommit(sc)
	if err := sign.VerifySchnorr(d.suite, pub, msg, sc.Signature); err != nil {
		return nil, err
	}

	deal := v.Deal()
	poly := share.NewPubPoly(d.suite, d.suite.Point().Base(), sc.Commitments)
	if !poly.Check(deal.SecShare) {
		cc := &ComplaintCommits{
			Index:       uint32(d.index),
			DealerIndex: sc.Index,
			SessionID:   sc.SessionID,
			Deal:        deal,
		}
		var err error
		msg := msgCommitComplaint(cc)
		if cc.Signature, err = sign.Schnorr(d.suite, d.long, msg); err != nil {
			return nil, err
		}
		return cc, nil
	}
	// commitments are fine
	d.commitments[sc.Index] = poly
	return nil, nil
}

func (d *DistKeyGenerator) ProcessCommitComplaint(cc *ComplaintCommits) (*vss.Deal, error) {
	issuer, ok := findPub(d.participants, cc.Index)
	if !ok {
		return nil, errors.New("dkg: commitcomplaint with unknown issuer")
	}
	if err := sign.VerifySchnorr(d.suite, issuer, msgCommitComplaint(cc), cc.Signature); err != nil {
		return nil, err
	}

	v, ok := d.verifiers[cc.DealerIndex]
	if !ok {
		return nil, errors.New("dkg: commitcomplaint linked to unknown verifier")
	}

	// the verification should pass for the deal, and not with the secret
	// commits
	if err := v.VerifyDeal(cc.Deal, false); err != nil {
		return nil, err
	}

	secretCommits, ok := d.commitments[cc.DealerIndex]
	if !ok {
		return nil, errors.New("dkg: complaint about non received commitments")
	}

	if secretCommits.Check(cc.Deal.SecShare) {
		return nil, errors.New("dkg: invalid complaints")
	}

	delete(d.commitments, cc.DealerIndex)

	deal := v.Deal()
	if deal == nil {
		return nil, errors.New("dkg: complaint linked to non certified deal")
	}
	return deal, nil
}

func (d *DistKeyGenerator) AddReconstructed(i int, secret abstract.Scalar) error {
	if int(uint32(i)) != i || i < 0 || i >= len(d.participants) {
		return errors.New("dkg: invalid index to add reconstructed secret")
	}
	_, ok := d.commitments[uint32(i)]
	if ok {
		return errors.New("dkg: commitments not invalidated by any complaints")
	}
	// register the "polynomial" with only the secret coefficient.
	commit := d.suite.Point().Mul(nil, secret)
	d.commitments[uint32(i)] = share.NewPubPoly(d.suite, d.suite.Point().Base(), []abstract.Point{commit})
	return nil
}

// ProduceSharedSecret will generate the sharedsecret relative to this receiver
// it will throw an error if something is wrong such as not enough Dealers received
// The shared secret can be computed when all deals have been sent and
// basically consists of a
// 1. Public point which is the sum of all aggregated individual public commits
// of each individual secrets.
// 2. Share of the global Private Polynomial (which is to never be computed directly), which is
// 		basically SUM of fj(i) for a receiver i
//
func (d *DistKeyGenerator) DistKeyShare() (*DistKeyShare, error) {
	if !d.Certified() {
		return nil, errors.New("dkg: distributed key not certified")
	}

	sh := d.suite.Scalar().Zero()
	pub := d.suite.Point().Null()
	// share of dist. secret = sum of all share received.
	// Dist. public key = sum of all revealed commitments
	var err error
	d.qualIter(func(i uint32, v *vss.Verifier) bool {
		s := v.Deal().SecShare.V
		sh = sh.Add(sh, s)
		poly, ok := d.commitments[i]
		if !ok {
			err = errors.New("dkg: distributed key not certified")
			return false
		}
		pub = pub.Add(pub, poly.Commit())
		return true
	})
	if err != nil {
		return nil, err
	}

	return &DistKeyShare{
		Public: pub,
		Share: &share.PriShare{
			I: int(d.index),
			V: sh,
		},
	}, nil
}

func msgSecretCommit(sc *SecretCommits) []byte {
	var buf bytes.Buffer
	buf.WriteString("secretcommits")
	buf.Write(sc.SessionID)
	binary.Write(&buf, binary.LittleEndian, sc.Index)
	for _, p := range sc.Commitments {
		p.MarshalTo(&buf)
	}
	return buf.Bytes()
}

func msgCommitComplaint(cc *ComplaintCommits) []byte {
	var buf bytes.Buffer
	buf.WriteString("commitcomplaint")
	buf.Write(cc.SessionID)
	binary.Write(&buf, binary.LittleEndian, cc.Index)
	binary.Write(&buf, binary.LittleEndian, cc.DealerIndex)
	buf.Write(cc.Deal.MarshalBinary())
	return buf.Bytes()
}

// XXX: maybe put that as internal package for vss & dkg since they both use the
// same function
func findPub(list []abstract.Point, i uint32) (abstract.Point, bool) {
	if i >= uint32(len(list)) {
		return nil, false
	}
	return list[i], true
}
